C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 15:43:09 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\outputs\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND OBJECT(.\output
                    -s\main.obj)

line level    source

   1          
   2          //#include "iic.h"
   3          #include "mpu6050.h"
   4          
   5          sbit LED    = P3^5;
   6          sbit SWITCH = P3^6;
   7          sbit KEY1   = P3^3;
   8          sbit KEY2   = P3^2;
   9          
  10          u8 _K1 = 0,_K2 = 0;
  11          u8 KEY1_DOWN=0,KEY2_DOWN=0;
  12          
  13          //运放电压与温度对应表  0  50  100  150  200  250  300  350  400  450
  14          //  adc
  15          //  |
  16          //      |____temp
  17          //
  18          #define TEMPMAPNUM 10
  19          static struct temperature_map{
  20                  int temp;
  21                  int adc;
  22                  float k;
  23                  float b;
  24          }temp_map[TEMPMAPNUM] = {{0,0},{50,100},{100,200},{150,300},{200,400},{250,500},{300,600},{350,750},{400,8
             -00},{450,850}};
  25                  
  26          
  27          void gpio_init(void);
  28          void ADC_init(void);
  29          u16 ADC_get_val(u8 channel);
  30          u16 temp2adcval(u16 temperature);
  31          u16 adc2tempval(u16 adcval);
  32          int get_pwmval_with_pid(u16 adcvalt12, u16 adcvalwant, u16 pwmmax);
  33          void Timer0_Init(void);
  34          
  35          int main()
  36          {
  37   1              u16 PWMVAL = 0;
  38   1              float powerval=0;
  39   1              u16 pwmtime = 0;
  40   1              u16 systime = 0;
  41   1              u32 t12adc_val = 0;
  42   1              u16 temp_want = 350,adc_want;
  43   1              s16 mpu_data=0;
  44   1              u8 i;
  45   1              
  46   1              for(i=0;i<TEMPMAPNUM-1;i++)
  47   1              {
  48   2                      temp_map[i].k = (temp_map[i+1].adc-temp_map[i].adc)/50.0f;
  49   2                      temp_map[i].b = temp_map[i].adc-temp_map[i].k*temp_map[i].temp;
  50   2              }
  51   1              
  52   1              gpio_init();
  53   1              OLED_Init();
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 15:43:09 PAGE 2   

  54   1              ADC_init();
  55   1              Timer0_Init();
  56   1              InitMPU6050();
  57   1              
  58   1              EA = 1;
  59   1              SWITCH = 0;
  60   1              
  61   1              while(1)
  62   1              {
  63   2                      if(pwmtime<PWMVAL)
  64   2                      {
  65   3                              SWITCH = 1;
  66   3                              LED = 0;
  67   3                      }
  68   2                      else
  69   2                      {
  70   3                              SWITCH = 0;
  71   3                              LED = 1;
  72   3                      }
  73   2                      delay_us(50);
  74   2                      pwmtime++;
  75   2                      if(pwmtime==2004)  //50*2000=100000us = 100ms周期
  76   2                      {
  77   3                              pwmtime = 0;
  78   3                              //计算当前电源电压并显示
  79   3                              powerval = ADC_get_val(1);
  80   3                              powerval = (powerval*3300)/4096;
  81   3                              powerval = powerval/10000*100;
  82   3                              OLED_ShowNum(0,2,powerval*10,5,16);
  83   3                              
  84   3                              //获取mpu6050是否运动
  85   3                              mpu_data = GetData(MPU_GYRO_XOUTH_REG);
  86   3                              
  87   3                              adc_want = temp2adcval(temp_want);
  88   3                              //计算运算放大器输出电压
  89   3                              t12adc_val = ADC_get_val(0);
  90   3                              t12adc_val = (t12adc_val*3300)/4096;
  91   3                              PWMVAL = get_pwmval_with_pid(t12adc_val,adc_want,2000);
  92   3                              OLED_ShowNum(0,0,adc2tempval(t12adc_val),5,16);
  93   3                              
  94   3                              if(KEY1_DOWN)
  95   3                              {
  96   4                                      OLED_ShowNum(54,0,temp_want+=KEY1_DOWN,6,16);
  97   4                                      KEY1_DOWN = 0;
  98   4                              }
  99   3                              if(KEY2_DOWN)
 100   3                              {
 101   4                                      OLED_ShowNum(54,0,temp_want-=KEY2_DOWN,6,16);
 102   4                                      KEY2_DOWN = 0;
 103   4                              }
 104   3                              systime++;
 105   3                      }
 106   2              }
 107   1      }
 108          
 109          
 110          void gpio_init(void)
 111          {
 112   1              P_SW2 |= 0x80;     //使能访问 XFR
 113   1              
 114   1              P3M0 |= (3<<5);    //设置 P3.5  P3.6为推挽模式   LED  SWITCH
 115   1              P3M1 &= ~(3<<5);
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 15:43:09 PAGE 3   

 116   1              
 117   1              P1M0 |= (3<<4);    //设置 P1.4  P1.5为开漏模式   IIC 带上拉电阻
 118   1              P1M1 |= (3<<4);
 119   1              
 120   1              P1M0 &= ~(3<<0);   //设置 P1.0  P1.1为高阻输入   ADC
 121   1              P1M1 |= (3<<0);
 122   1              
 123   1              P3M0 &= ~(3<<2);    //设置 P3.2  P3.3为准双向模式   KEY
 124   1              P3M1 &= ~(3<<2);
 125   1              
 126   1              KEY1=1;
 127   1              KEY2=1;
 128   1              SCL=1;
 129   1              SDA=1;
 130   1      }
 131          
 132          void ADC_init(void)
 133          {
 134   1              ADCTIM = 0x3f;//设置 ADC 内部时序
 135   1              ADCCFG = 0x0f;//设置 ADC 时钟为系统时钟/2/16
 136   1              ADC_CONTR = 0x80;//使能 ADC 模块
 137   1      }
 138          
 139          
 140          u16 ADC_get_val(u8 channel)
 141          {
 142   1              ADC_CONTR |= 0x40;        //启动 AD 转换
 143   1              
 144   1              ADC_CONTR &= ~(0xf);
 145   1              ADC_CONTR |= channel;
 146   1              
 147   1              _nop_();
 148   1              _nop_();
 149   1              while (!(ADC_CONTR & 0x20));//查询 ADC 完成标志
 150   1              ADC_CONTR &= ~0x20;         //清完成标志
 151   1              P2 = ADC_RES;               //读取 ADC 结果
 152   1              return (ADC_RES<<4)|(ADC_RESL>>4);
 153   1      }
 154          
 155          
 156          u16 temp2adcval(u16 temperature)
 157          {
 158   1              u8 i=0;
 159   1              
 160   1              for(i=0;i<TEMPMAPNUM-1;i++)
 161   1              {
 162   2                      if(temperature>=temp_map[i].temp&&temperature<temp_map[i+1].temp)
 163   2                      {
 164   3                              return temp_map[i].k*temperature+temp_map[i].b;
 165   3                      }
 166   2              }
 167   1      }
 168          
 169          u16 adc2tempval(u16 adcval)
 170          {
 171   1              u8 i=0;
 172   1              
 173   1              for(i=0;i<TEMPMAPNUM-1;i++)
 174   1              {
 175   2                      if(adcval>=temp_map[i].adc&&adcval<temp_map[i+1].adc)
 176   2                      {
 177   3                              return (adcval-temp_map[i].b)/temp_map[i].k;
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 15:43:09 PAGE 4   

 178   3                      }
 179   2              }
 180   1      }
 181          
 182          
 183          #define PVAL  20.0F
 184          #define IVAL  0.0F
 185          #define DVAL  0.0F
 186          int get_pwmval_with_pid(u16 adcvalt12, u16 adcvalwant, u16 pwmmax)
 187          {
 188   1              float pwm_val = 0;
 189   1              int diff = adcvalwant - adcvalt12;
 190   1              pwm_val = PVAL*diff;
 191   1              if(pwm_val<0)
 192   1                      pwm_val = -pwm_val;
 193   1              if(pwm_val > pwmmax)
 194   1                      pwm_val = pwmmax;
 195   1              if(adcvalt12>adcvalwant)
 196   1                      return 100;
 197   1              return pwm_val;
 198   1      }
 199          
 200          void Timer0_Isr(void) interrupt 1
 201          {
 202   1              if(KEY1==0){
 203   2                      _K1+=1;
 204   2              }else{
 205   2                      _K1=0;
 206   2              }
 207   1              if(KEY2==0){
 208   2                      _K2+=1;
 209   2              }else{
 210   2                      _K2=0;
 211   2              }
 212   1              if(_K1>70)
 213   1              {
 214   2                      _K1=0;
 215   2                      KEY1_DOWN+=1;
 216   2              }
 217   1              if(_K2>70)
 218   1              {
 219   2                      _K2=0;
 220   2                      KEY2_DOWN+=1;
 221   2              }
 222   1      }
 223          
 224          void Timer0_Init(void)          //1000微秒@40.000MHz
 225          {
 226   1              AUXR |= 0x80;                   //定时器时钟1T模式
 227   1              TMOD &= 0xF0;                   //设置定时器模式
 228   1              TL0 = 0xC0;                             //设置定时初始值
 229   1              TH0 = 0x63;                             //设置定时初始值
 230   1              TF0 = 0;                                //清除TF0标志
 231   1              TR0 = 1;                                //定时器0开始计时
 232   1              ET0 = 1;                                //使能定时器0中断
 233   1      }
 234          
 235          
*** WARNING C291 IN LINE 167 OF main.c: not every exit path returns a value
*** WARNING C291 IN LINE 180 OF main.c: not every exit path returns a value


C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 15:43:09 PAGE 5   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1525    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    124      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
