C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\outputs\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND OBJECT(.\output
                    -s\main.obj)

line level    source

   1          
   2          //#include "iic.h"
   3          #include "mpu6050.h"
   4          
   5          sbit LED    = P3^5;
   6          sbit SWITCH = P3^6;
   7          sbit KEY1   = P3^3;
   8          sbit KEY2   = P3^2;
   9          
  10          u8 _K1 = 0,_K2 = 0;
  11          u8 KEY1_DOWN=0,KEY2_DOWN=0;
  12          
  13          //运放电压与温度对应表  0  50  100  150  200  250  300  350  400  450
  14          //  adc
  15          //  |
  16          //      |____temp
  17          //
  18          #define TEMPMAPNUM 10
  19          static struct temperature_map{
  20                  int temp;
  21                  int adc;
  22                  float k;
  23                  float b;
  24          }temp_map[TEMPMAPNUM] = {{0,0},
  25                                                          {50,100},
  26                                                          {100,200},
  27                                                          {150,300},
  28                                                          {200,400},
  29                                                          {250,500},
  30                                                          {300,600},
  31                                                          {350,750},
  32                                                          {400,800},
  33                                                          {450,850}};
  34                  
  35          #define ADCARRAYNUM 5
  36          #define SLEEPTIME   300
  37          #define MPUGRYLIEMT 10
  38          
  39          
  40          void gpio_init(void);
  41          void ADC_init(void);
  42          u16 ADC_get_val(u8 channel);
  43          u16 temp2adcval(u16 temperature);
  44          u16 adc2tempval(u16 adcval);
  45          int get_pwmval_with_pid(u16 adcvalt12, u16 adcvalwant, u16 pwmmax);
  46          void Timer0_Init(void);
  47          
  48                                                          
  49                                                          
  50          #if 1
  51          int main()
  52          {
  53   1              u16 PWMVAL = 0;
  54   1              float powerval=0;
C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 2   

  55   1              u16 pwmtime = 0;
  56   1              u32 t12adc_val[ADCARRAYNUM] = {0}, t12adc_max, t12adc_min, t12adc_all, t12adc_average, t12adc_i=0;   //ad
             -c均值滤波  adc电压单位mV
  57   1              u16 temp_want = 350,adc_want;
  58   1              s16 mpu_data=0,mpu_diff=0,mpu_time=0,mpu_temp;
  59   1              u8 i;
  60   1              
  61   1      
  62   1              for(i=0;i<TEMPMAPNUM-1;i++)
  63   1              {
  64   2                      temp_map[i].k = (temp_map[i+1].adc-temp_map[i].adc)/50.0f;
  65   2                      temp_map[i].b = temp_map[i].adc-temp_map[i].k*temp_map[i].temp;
  66   2              }
  67   1              
  68   1              gpio_init();
  69   1              OLED_Init();
  70   1              ADC_init();
  71   1              Timer0_Init();
  72   1              InitMPU6050();
  73   1              
  74   1              EA = 1;
  75   1              SWITCH = 0;
  76   1      
  77   1              OLED_ShowString(72,0,"Set:",8);
  78   1              OLED_ShowString(72,1,"Pow:",8);
  79   1              OLED_ShowString(72,2,"Tmp:",8);
  80   1              OLED_ShowNum(102,0,temp_want,3,8);
  81   1              
  82   1              
  83   1              OLED_ShowNum(102,2,mpu_temp,3,8);
  84   1              
  85   1              while(1)
  86   1              {
  87   2                      //加热
  88   2                      if(pwmtime<PWMVAL)
  89   2                      {
  90   3                              SWITCH = 1;
  91   3                              LED = 0;
  92   3                      }
  93   2                      //断开
  94   2                      else
  95   2                      {
  96   3                              SWITCH = 0;
  97   3                              LED = 1;
  98   3                      }
  99   2                      delay_us(25);
 100   2                      pwmtime++;
 101   2                      if(pwmtime==2501)  //25*2500=62500us = 62.5ms = 16Hz
 102   2                      {
 103   3                              pwmtime = 0;
 104   3                              mpu_data = GetData(MPU_GYRO_YOUTH_REG);
 105   3                              
 106   3                              //非全速加热时获取当前电压与mpu6050温度数据
 107   3                              if((2500-PWMVAL)>1000)
 108   3                              {
 109   4      //                              //计算当前电源电压并显示
 110   4      //                              powerval = ADC_get_val(1);
 111   4      //                              powerval = (powerval*3300)/4096;
 112   4      //                              powerval = powerval/10000*100;
 113   4      //                              OLED_ShowNum(102,1,powerval*10,3,8);
 114   4      //                              mpu_temp = MPU_Get_Temperature();
 115   4      //                              OLED_ShowNum(102,2,mpu_temp,3,8);
C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 3   

 116   4                                      OLED_ShowNum(10,2,mpu_data,5,8);
 117   4                              }
 118   3      
 119   3                              //根据设定的温度获取T12热电偶电压值（adc值）
 120   3                              adc_want = temp2adcval(temp_want);
 121   3      
 122   3                              //adc滤波数组去掉最大最小值，求均值
 123   3                              t12adc_max=t12adc_val[0];
 124   3                              t12adc_min=t12adc_val[0];
 125   3                              t12adc_all = 0;
 126   3                              for(i=0;i<ADCARRAYNUM;i++)
 127   3                              {
 128   4                                      if(t12adc_val[i]<t12adc_min)
 129   4                                              t12adc_min = t12adc_val[i];
 130   4                                      if(t12adc_val[i]>t12adc_max)
 131   4                                              t12adc_max = t12adc_val[i];
 132   4                                      t12adc_all += t12adc_val[i];
 133   4                              }
 134   3                              t12adc_average = (t12adc_all-t12adc_max-t12adc_min)/(ADCARRAYNUM-2);
 135   3                              PWMVAL = get_pwmval_with_pid(t12adc_average,adc_want,2500);
 136   3                              OLED_ShowNum(32,0,adc2tempval(t12adc_average),3,16);
 137   3      
 138   3                              //计算运算放大器输出电压，填充数组
 139   3                              t12adc_val[t12adc_i] = ADC_get_val(0);
 140   3                              t12adc_val[t12adc_i] = (t12adc_val[t12adc_i]*3300)/4096;
 141   3                              t12adc_i++;
 142   3                              if(t12adc_i==ADCARRAYNUM)
 143   3                                      t12adc_i = 0;
 144   3                              
 145   3                              //按键检测
 146   3                              if(KEY1_DOWN&&KEY2_DOWN)  //同时按下
 147   3                              {
 148   4                                      KEY1_DOWN = 0;
 149   4                                      KEY2_DOWN = 0;
 150   4                                      
 151   4                              }
 152   3                              if(KEY1_DOWN)   //KEY1按下
 153   3                              {
 154   4                                      temp_want+=KEY1_DOWN;
 155   4                                      if(temp_want>450)
 156   4                                              temp_want = 450;
 157   4                                      OLED_ShowNum(102,0,temp_want,3,8);
 158   4                                      KEY1_DOWN = 0;
 159   4                              }
 160   3                              if(KEY2_DOWN)  //KEY2按下
 161   3                              {
 162   4                                      temp_want-=KEY2_DOWN;
 163   4                                      if(temp_want<0)
 164   4                                              temp_want = 0;
 165   4                                      OLED_ShowNum(102,0,temp_want,3,8);
 166   4                                      KEY2_DOWN = 0;
 167   4                              }
 168   3                      }
 169   2              }
 170   1      }
 171          #else
              //硬件测试
              int main()
              {
                      u8 flag=0;
                      s16 mpu_data,mpu_temp;
                      float powerval;
C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 4   

                      
                      gpio_init();
                      OLED_Init();
                      ADC_init();
                      Timer0_Init();
                      InitMPU6050();
                      
                      EA = 1;
                      SWITCH = 0;
                      
                      while(1)
                      {
                              mpu_data = GetData(MPU_GYRO_YOUTH_REG);
                              mpu_temp = MPU_Get_Temperature();
              
                              if(mpu_data<0)
                              {
                                      mpu_data = -mpu_data;
                                      OLED_ShowString(0,0,"-",8);
                              }
                              else
                              {
                                      OLED_ShowString(0,0,"+",8);
                              }
                                      
                              OLED_ShowNum(10,0,mpu_data,5,8);
                              OLED_ShowNum(72,0,mpu_temp,4,8);
                              
                              
                              //计算当前电源电压并显示
                              powerval = ADC_get_val(1);
                              powerval = (powerval*3300)/4096;
                              powerval = powerval/10000*100;
                              OLED_ShowNum(10,1,powerval*10,3,8);
                              
                              if(flag==1)
                              {
                                      SWITCH = 1;
                                      LED = 0;
                                      flag = 0;
                              }
                              else
                              {
                                      SWITCH = 0;
                                      LED = 1;
                                      flag = 1;
                              }
                              
                              delay_ms(60);
                      }
              }
              #endif
 230          
 231          
 232          void gpio_init(void)
 233          {
 234   1              P_SW2 |= 0x80;     //使能访问 XFR
 235   1              
 236   1              P3M0 |= (3<<5);    //设置 P3.5  P3.6为推挽模式   LED & SWITCH
 237   1              P3M1 &= ~(3<<5);
 238   1              
 239   1              P1M0 |= (3<<4);    //设置 P1.4  P1.5为开漏模式   IIC 带上拉电阻
C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 5   

 240   1              P1M1 |= (3<<4);
 241   1              
 242   1              P1M0 &= ~(3<<0);   //设置 P1.0  P1.1为高阻输入   ADC
 243   1              P1M1 |= (3<<0);
 244   1              
 245   1              P3M0 &= ~(3<<2);    //设置 P3.2  P3.3为准双向模式   KEY
 246   1              P3M1 &= ~(3<<2);
 247   1              
 248   1              KEY1=1;
 249   1              KEY2=1;
 250   1              SCL=1;
 251   1              SDA=1;
 252   1      }
 253          
 254          void ADC_init(void)
 255          {
 256   1              ADCTIM = 0x3f;//设置 ADC 内部时序
 257   1              ADCCFG = 0x0f;//设置 ADC 时钟为系统时钟/2/16
 258   1              ADC_CONTR = 0x80;//使能 ADC 模块
 259   1      }
 260          
 261          
 262          u16 ADC_get_val(u8 channel)
 263          {
 264   1              ADC_CONTR |= 0x40;        //启动 AD 转换
 265   1              
 266   1              ADC_CONTR &= ~(0xf);
 267   1              ADC_CONTR |= channel;
 268   1              
 269   1              _nop_();
 270   1              _nop_();
 271   1              while (!(ADC_CONTR & 0x20));//查询 ADC 完成标志
 272   1              ADC_CONTR &= ~0x20;         //清完成标志
 273   1              P2 = ADC_RES;               //读取 ADC 结果
 274   1              return (ADC_RES<<4)|(ADC_RESL>>4);
 275   1      }
 276          
 277          
 278          u16 temp2adcval(u16 temperature)
 279          {
 280   1              u8 i=0;
 281   1              
 282   1              for(i=0;i<TEMPMAPNUM-1;i++)
 283   1              {
 284   2                      if(temperature>=temp_map[i].temp&&temperature<temp_map[i+1].temp)
 285   2                      {
 286   3                              return temp_map[i].k*temperature+temp_map[i].b;
 287   3                      }
 288   2              }
 289   1              return temp_map[i].k*temperature+temp_map[i].b;
 290   1      }
 291          
 292          u16 adc2tempval(u16 adcval)
 293          {
 294   1              u8 i=0;
 295   1              
 296   1              for(i=0;i<TEMPMAPNUM-1;i++)
 297   1              {
 298   2                      if(adcval>=temp_map[i].adc&&adcval<temp_map[i+1].adc)
 299   2                      {
 300   3                              return (adcval-temp_map[i].b)/temp_map[i].k;
 301   3                      }
C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 6   

 302   2              }
 303   1              return (adcval-temp_map[i].b)/temp_map[i].k;
 304   1      }
 305          
 306          
 307          #define PVAL  25.0F
 308          #define IVAL  0.82F
 309          #define DVAL  1.20F
 310          #define INTEGRAL 1500
 311          int get_pwmval_with_pid(u16 adcvalt12, u16 adcvalwant, u16 pwmmax)
 312          {
 313   1              static s16  lasterror=0, integralval=0;
 314   1              s16 error,derror, pwmval=0;
 315   1              error = adcvalwant - adcvalt12;
 316   1              integralval += error;
 317   1              if(integralval>INTEGRAL)
 318   1                      integralval = INTEGRAL;
 319   1              if(integralval<-INTEGRAL)
 320   1                      integralval = -INTEGRAL;
 321   1              
 322   1              derror = error - lasterror;
 323   1              pwmval = PVAL*error + IVAL*integralval + DVAL*derror;
 324   1              lasterror = error;
 325   1              
 326   1              if(pwmval > pwmmax)
 327   1                      pwmval = pwmmax;
 328   1              return pwmval;
 329   1      }
 330          
 331          void Timer0_Isr(void) interrupt 1
 332          {
 333   1              if(KEY1==0){
 334   2                      _K1+=1;
 335   2              }else{
 336   2                      _K1=0;
 337   2              }
 338   1              if(KEY2==0){
 339   2                      _K2+=1;
 340   2              }else{
 341   2                      _K2=0;
 342   2              }
 343   1              if(_K1>80)
 344   1              {
 345   2                      _K1=0;
 346   2                      KEY1_DOWN+=1;
 347   2              }
 348   1              if(_K2>80)
 349   1              {
 350   2                      _K2=0;
 351   2                      KEY2_DOWN+=1;
 352   2              }
 353   1      }
 354          
 355          void Timer0_Init(void)          //1000微秒@40.000MHz
 356          {
 357   1              AUXR |= 0x80;                   //定时器时钟1T模式
 358   1              TMOD &= 0xF0;                   //设置定时器模式
 359   1              TL0 = 0xC0;                             //设置定时初始值
 360   1              TH0 = 0x63;                             //设置定时初始值
 361   1              TF0 = 0;                                //清除TF0标志
 362   1              TR0 = 1;                                //定时器0开始计时
 363   1              ET0 = 1;                                //使能定时器0中断
C51 COMPILER V9.60.7.0   MAIN                                                              03/28/2024 11:13:06 PAGE 7   

 364   1      }
 365          
 366          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2238    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =    128      73
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
