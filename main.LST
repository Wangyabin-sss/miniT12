C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 16:10:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\outputs\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND OBJECT(.\output
                    -s\main.obj)

line level    source

   1          
   2          //#include "iic.h"
   3          #include "mpu6050.h"
   4          
   5          sbit LED    = P3^5;
   6          sbit SWITCH = P3^6;
   7          sbit KEY1   = P3^3;
   8          sbit KEY2   = P3^2;
   9          
  10          u8 _K1 = 0,_K2 = 0;
  11          u8 KEY1_DOWN=0,KEY2_DOWN=0;
  12          
  13          //运放电压与温度对应表  0  50  100  150  200  250  300  350  400  450
  14          //  adc
  15          //  |
  16          //      |____temp
  17          //
  18          #define TEMPMAPNUM 10
  19          static struct temperature_map{
  20                  int temp;
  21                  int adc;
  22                  float k;
  23                  float b;
  24          }temp_map[TEMPMAPNUM] = {{0,0},{50,100},{100,200},{150,300},{200,400},{250,500},{300,600},{350,750},{400,8
             -00},{450,850}};
  25                  
  26          
  27          
  28          void gpio_init(void);
  29          void ADC_init(void);
  30          u16 ADC_get_val(u8 channel);
  31          u16 temp2adcval(u16 temperature);
  32          u16 adc2tempval(u16 adcval);
  33          int get_pwmval_with_pid(u16 adcvalt12, u16 adcvalwant, u16 pwmmax);
  34          void Timer0_Init(void);
  35          
  36          int main()
  37          {
  38   1              u16 PWMVAL = 0;
  39   1              float powerval=0;
  40   1              u16 pwmtime = 0;
  41   1              u16 systime = 0;
  42   1              u32 t12adc_val[6] = {0}, t12adc_max, t12adc_min, t12adc_all, t12adc_average, t12adc_i=0;
  43   1              u16 temp_want = 350,adc_want;
  44   1              s16 mpu_data=0;
  45   1              u8 i;
  46   1              
  47   1              for(i=0;i<TEMPMAPNUM-1;i++)
  48   1              {
  49   2                      temp_map[i].k = (temp_map[i+1].adc-temp_map[i].adc)/50.0f;
  50   2                      temp_map[i].b = temp_map[i].adc-temp_map[i].k*temp_map[i].temp;
  51   2              }
  52   1              
  53   1              gpio_init();
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 16:10:53 PAGE 2   

  54   1              OLED_Init();
  55   1              ADC_init();
  56   1              Timer0_Init();
  57   1              InitMPU6050();
  58   1              
  59   1              EA = 1;
  60   1              SWITCH = 0;
  61   1      
  62   1              OLED_ShowNum(54,0,temp_want,6,16);
  63   1              
  64   1              while(1)
  65   1              {
  66   2                      if(pwmtime<PWMVAL)
  67   2                      {
  68   3                              SWITCH = 1;
  69   3                              LED = 0;
  70   3                      }
  71   2                      else
  72   2                      {
  73   3                              SWITCH = 0;
  74   3                              LED = 1;
  75   3                      }
  76   2                      delay_us(50);
  77   2                      pwmtime++;
  78   2                      if(pwmtime==2004)  //50*2000=100000us = 100ms周期
  79   2                      {
  80   3                              pwmtime = 0;
  81   3                              //计算当前电源电压并显示
  82   3                              powerval = ADC_get_val(1);
  83   3                              powerval = (powerval*3300)/4096;
  84   3                              powerval = powerval/10000*100;
  85   3                              OLED_ShowNum(0,2,powerval*10,5,16);
  86   3                              
  87   3                              //获取mpu6050是否运动
  88   3                              mpu_data = GetData(MPU_GYRO_XOUTH_REG);
  89   3                              
  90   3                              //根据设定的温度转adc值
  91   3                              adc_want = temp2adcval(temp_want);
  92   3                              //计算运算放大器输出电压
  93   3                              t12adc_val[t12adc_i] = ADC_get_val(0);
  94   3                              t12adc_val[t12adc_i] = (t12adc_val[t12adc_i]*3300)/4096;
  95   3                              t12adc_i++;
  96   3                              if(t12adc_i==6)
  97   3                                      t12adc_i = 0;
  98   3                              t12adc_max=t12adc_val[0];
  99   3                              t12adc_min=t12adc_val[0];
 100   3                              t12adc_all = 0;
 101   3                              for(i=0;i<6;i++)
 102   3                              {
 103   4                                      if(t12adc_val[i]<t12adc_min)
 104   4                                              t12adc_min = t12adc_val[i];
 105   4                                      if(t12adc_val[i]>t12adc_max)
 106   4                                              t12adc_max = t12adc_val[i];
 107   4                                      t12adc_all += t12adc_val[i];
 108   4                              }
 109   3                              t12adc_average = (t12adc_all-t12adc_max-t12adc_min)/4.0f;
 110   3                              PWMVAL = get_pwmval_with_pid(t12adc_average,adc_want,2000);
 111   3                              OLED_ShowNum(0,0,adc2tempval(t12adc_average),5,16);
 112   3                              
 113   3                              if(KEY1_DOWN)
 114   3                              {
 115   4                                      OLED_ShowNum(54,0,temp_want+=KEY1_DOWN,6,16);
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 16:10:53 PAGE 3   

 116   4                                      KEY1_DOWN = 0;
 117   4                              }
 118   3                              if(KEY2_DOWN)
 119   3                              {
 120   4                                      OLED_ShowNum(54,0,temp_want-=KEY2_DOWN,6,16);
 121   4                                      KEY2_DOWN = 0;
 122   4                              }
 123   3                              systime++;
 124   3                      }
 125   2              }
 126   1      }
 127          
 128          
 129          void gpio_init(void)
 130          {
 131   1              P_SW2 |= 0x80;     //使能访问 XFR
 132   1              
 133   1              P3M0 |= (3<<5);    //设置 P3.5  P3.6为推挽模式   LED  SWITCH
 134   1              P3M1 &= ~(3<<5);
 135   1              
 136   1              P1M0 |= (3<<4);    //设置 P1.4  P1.5为开漏模式   IIC 带上拉电阻
 137   1              P1M1 |= (3<<4);
 138   1              
 139   1              P1M0 &= ~(3<<0);   //设置 P1.0  P1.1为高阻输入   ADC
 140   1              P1M1 |= (3<<0);
 141   1              
 142   1              P3M0 &= ~(3<<2);    //设置 P3.2  P3.3为准双向模式   KEY
 143   1              P3M1 &= ~(3<<2);
 144   1              
 145   1              KEY1=1;
 146   1              KEY2=1;
 147   1              SCL=1;
 148   1              SDA=1;
 149   1      }
 150          
 151          void ADC_init(void)
 152          {
 153   1              ADCTIM = 0x3f;//设置 ADC 内部时序
 154   1              ADCCFG = 0x0f;//设置 ADC 时钟为系统时钟/2/16
 155   1              ADC_CONTR = 0x80;//使能 ADC 模块
 156   1      }
 157          
 158          
 159          u16 ADC_get_val(u8 channel)
 160          {
 161   1              ADC_CONTR |= 0x40;        //启动 AD 转换
 162   1              
 163   1              ADC_CONTR &= ~(0xf);
 164   1              ADC_CONTR |= channel;
 165   1              
 166   1              _nop_();
 167   1              _nop_();
 168   1              while (!(ADC_CONTR & 0x20));//查询 ADC 完成标志
 169   1              ADC_CONTR &= ~0x20;         //清完成标志
 170   1              P2 = ADC_RES;               //读取 ADC 结果
 171   1              return (ADC_RES<<4)|(ADC_RESL>>4);
 172   1      }
 173          
 174          
 175          u16 temp2adcval(u16 temperature)
 176          {
 177   1              u8 i=0;
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 16:10:53 PAGE 4   

 178   1              
 179   1              for(i=0;i<TEMPMAPNUM-1;i++)
 180   1              {
 181   2                      if(temperature>=temp_map[i].temp&&temperature<temp_map[i+1].temp)
 182   2                      {
 183   3                              return temp_map[i].k*temperature+temp_map[i].b;
 184   3                      }
 185   2              }
 186   1      }
 187          
 188          u16 adc2tempval(u16 adcval)
 189          {
 190   1              u8 i=0;
 191   1              
 192   1              for(i=0;i<TEMPMAPNUM-1;i++)
 193   1              {
 194   2                      if(adcval>=temp_map[i].adc&&adcval<temp_map[i+1].adc)
 195   2                      {
 196   3                              return (adcval-temp_map[i].b)/temp_map[i].k;
 197   3                      }
 198   2              }
 199   1      }
 200          
 201          
 202          #define PVAL  20.0F
 203          #define IVAL  0.0F
 204          #define DVAL  0.0F
 205          int get_pwmval_with_pid(u16 adcvalt12, u16 adcvalwant, u16 pwmmax)
 206          {
 207   1              float pwm_val = 0;
 208   1              int diff = adcvalwant - adcvalt12;
 209   1              pwm_val = PVAL*diff;
 210   1              if(pwm_val<0)
 211   1                      pwm_val = -pwm_val;
 212   1              if(pwm_val > pwmmax)
 213   1                      pwm_val = pwmmax;
 214   1              if(adcvalt12>adcvalwant)
 215   1                      return 100;
 216   1              return pwm_val;
 217   1      }
 218          
 219          void Timer0_Isr(void) interrupt 1
 220          {
 221   1              if(KEY1==0){
 222   2                      _K1+=1;
 223   2              }else{
 224   2                      _K1=0;
 225   2              }
 226   1              if(KEY2==0){
 227   2                      _K2+=1;
 228   2              }else{
 229   2                      _K2=0;
 230   2              }
 231   1              if(_K1>70)
 232   1              {
 233   2                      _K1=0;
 234   2                      KEY1_DOWN+=1;
 235   2              }
 236   1              if(_K2>70)
 237   1              {
 238   2                      _K2=0;
 239   2                      KEY2_DOWN+=1;
C51 COMPILER V9.60.7.0   MAIN                                                              09/10/2023 16:10:53 PAGE 5   

 240   2              }
 241   1      }
 242          
 243          void Timer0_Init(void)          //1000微秒@40.000MHz
 244          {
 245   1              AUXR |= 0x80;                   //定时器时钟1T模式
 246   1              TMOD &= 0xF0;                   //设置定时器模式
 247   1              TL0 = 0xC0;                             //设置定时初始值
 248   1              TH0 = 0x63;                             //设置定时初始值
 249   1              TF0 = 0;                                //清除TF0标志
 250   1              TR0 = 1;                                //定时器0开始计时
 251   1              ET0 = 1;                                //使能定时器0中断
 252   1      }
 253          
 254          
*** WARNING C291 IN LINE 186 OF main.c: not every exit path returns a value
*** WARNING C291 IN LINE 199 OF main.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2105    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =    124      77
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
